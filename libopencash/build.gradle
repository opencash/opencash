buildscript {
    repositories {
        maven {
            url "https://sgeb.github.io/maven_repo/"
        }
    }

    dependencies {
        classpath "me.sgeb.gradle:gradle-native-artifacts-plugin:1.1.0-SNAPSHOT"
    }
}

def localIvyRepoUri = uri("$rootProject.projectDir/../local_ivy_repo")
if (System.env.IVY_REPO_DIR) { localIvyRepoUri = System.env.IVY_REPO_DIR }

apply plugin: 'cpp'
apply plugin: 'native-artifacts'
apply plugin: 'ivy-publish'

group "com.github.opencash"
version "0.1.0"
status "integration"

repositories {
    ivy {
        url localIvyRepoUri
    }
    ivy {
        url "https://opencash.github.io/ivy_repo/"
    }
}

model {
    platforms {
        "osx-x86_64" {
            operatingSystem "osx"
            architecture "x86_64"
        }

        "linux-amd64" {
            operatingSystem "linux"
            architecture "amd64"
        }

        "android-arm" {
            operatingSystem "linux"
            architecture "arm"
        }
    }

    buildTypes {
        debug
        release
    }

    toolChains {
        gcc(Gcc)
        clang(Clang)

        "linux-amd64"(Gcc) {
            def prefix = "x86_64-pc-linux-"
            CCompiler.executable         = prefix + CCompiler.executable
            cppCompiler.executable       = prefix + cppCompiler.executable
            assembler.executable         = prefix + assembler.executable
            linker.executable            = prefix + linker.executable
            staticLibArchiver.executable = prefix + staticLibArchiver.executable

            addPlatformConfiguration(new LinuxAmd64Configuration())
        }

        "android-arm"(Gcc) {
            def prefix = "arm-linux-androideabi-"
            CCompiler.executable         = prefix + CCompiler.executable
            cppCompiler.executable       = prefix + cppCompiler.executable
            assembler.executable         = prefix + assembler.executable
            linker.executable            = prefix + linker.executable
            staticLibArchiver.executable = prefix + staticLibArchiver.executable

            addPlatformConfiguration(new AndroidArmConfiguration())
        }
    }
}

libraries {
    opencash {
        binaries.all { binary ->
            cppCompiler.args '-I', "$projectDir/src/core/generated" // TODO: ugly hack for relative includes, needs fixing!
        }
    }
}

executables.all { ext.purpose = null }
executables {
    unitTests {
        purpose = 'test'

        binaries.all { binary ->
            targetBuildTypes "debug"

            lib libraries.opencash.static

            def myPlatform = binary.targetPlatform.name
            project.dependencies {
                add binary.narConfName,
                    [group: "com.github.opencash.vendor", name: "gtest",
                        version: "1.7.0", configuration: myPlatform]

                add binary.narConfName,
                    [group: "com.github.opencash.vendor", name: "gmock",
                        version: "1.7.0", configuration: myPlatform]
            }

            cppCompiler.args '-I', "$projectDir/src" // TODO: ugly hack for relative includes, needs fixing!

            linker.args '-lgtest'
            linker.args '-lgtest_main'
            linker.args '-lgmock'
            linker.args '-lgmock_main'
            linker.args '-lPocoFoundation'
            linker.args '-lodb-sqlite'
            linker.args '-lodb'
            linker.args '-lsqlite3'

            if (binary.targetPlatform in platforms."linux-amd64") {
                linker.args '-lpthread'
            }
        }
    }
}

sources {
    opencash {
        cpp {
            source {
                srcDir "src"
                include "**/*.cpp"
                include "**/*.cxx"
            }
            exportedHeaders {
                srcDir "include"
            }
        }
    }

    unitTests {
        cpp {
            source {
                srcDir "test"
                include "**/*.cpp"
            }
            exportedHeaders {
                srcDir "include"
            }
        }
    }
}

binaries.all { binary ->
    def myPlatform = binary.targetPlatform.name
    project.dependencies {
        add binary.narConfName,
            [group: "com.github.opencash.vendor", name: "poco",
                version: "1.5.2", configuration: myPlatform]

        add binary.narConfName,
            [group: "com.github.opencash.vendor", name: "libodb",
                version: "2.3.0", configuration: myPlatform]

        add binary.narConfName,
            [group: "com.github.opencash.vendor", name: "libodb-sqlite",
                version: "2.3.0", configuration: myPlatform]
    }

    if (toolChain in Gcc || toolChain in Clang) {
        cppCompiler.args "-std=c++11"
        cppCompiler.args "-I${binary.narDepsDir}/include"

        // Mac OS X must build with libc++
        if (targetPlatform.operatingSystem.macOsX) {
            cppCompiler.args "-stdlib=libc++"
            linker.args "-lc++"
        }

        if (buildType == buildTypes.debug) {
            cppCompiler.args "-g"
        }

        if (buildType == buildTypes.release) {
            cppCompiler.args "-O2"
        }

        linker.args "-L${binary.narDepsDir}/lib"
    }
}

nativeArtifacts {
    libopencash {
        from (libraries.opencash) {
            it instanceof StaticLibraryBinary &&
            it.buildType == buildTypes.debug
        }
    }
}

publishing {
    publications {
        libopencash(IvyPublication) {
            from nativeArtifacts.libopencash
        }
    }

    repositories {
        ivy {
            url localIvyRepoUri
        }
    }
}

task build {
    description "Builds all binaries on all buildable platforms (except shared libs)."
    dependsOn binaries.matching { it.buildable && !(it instanceof SharedLibraryBinary) }
}

task test {
    description "Builds and runs all tests for current platform."

    def testExecutables = binaries.withType(ExecutableBinary).matching {
        it.component.purpose == "test" &&
            it.targetPlatform.operatingSystem.current &&
            it.targetPlatform.architecture.name == System.properties['os.arch']
    }

    dependsOn testExecutables

    doLast {
        testExecutables.all { test ->
            def tempDir = new File(temporaryDir, test.executableFile.name)
            tempDir.mkdirs()
            exec {
              logger.quiet ""
              logger.quiet ">>> Testing `${relativePath test.executableFile}`"
              logger.quiet ">>> in dir `${tempDir}`"
              logger.quiet ""
              workingDir tempDir
              commandLine test.executableFile
            }
        }
    }
}

task wrapper(type: Wrapper) {
    description 'Updates the wrapper'
    gradleVersion = '1.11'
}

defaultTasks("tasks")

//////////////////////////////////////////////////////////////////////////////

class LinuxAmd64Configuration implements TargetPlatformConfiguration {
    boolean supportsPlatform(Platform platform) {
        return platform.operatingSystem.linux && platform.architecture.amd64
    }

    List<String> getCCompilerArgs() {
        []
    }

    List<String> getCppCompilerArgs() {
        []
    }

    List<String> getObjectiveCCompilerArgs() {
        []
    }

    List<String> getObjectiveCppCompilerArgs() {
        []
    }

    List<String> getAssemblerArgs() {
        []
    }

    List<String> getLinkerArgs() {
        []
    }

    List<String> getStaticLibraryArchiverArgs() {
        []
    }
}

//////////////////////////////////////////////////////////////////////////////

class AndroidArmConfiguration implements TargetPlatformConfiguration {
    boolean supportsPlatform(Platform platform) {
        return platform.operatingSystem.linux &&
            platform.architecture.arm &&
            platform.name.toLowerCase().contains("android")
    }

    List<String> getCCompilerArgs() {
        []
    }

    List<String> getCppCompilerArgs() {
        []
    }

    List<String> getObjectiveCCompilerArgs() {
        []
    }

    List<String> getObjectiveCppCompilerArgs() {
        []
    }

    List<String> getAssemblerArgs() {
        []
    }

    List<String> getLinkerArgs() {
        []
    }

    List<String> getStaticLibraryArchiverArgs() {
        []
    }
}
